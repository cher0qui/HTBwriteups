
# Docker
Vemos los recursos docker de la maquina :

```bash
CONTAINER ID   IMAGE                       COMMAND                  CREATED        STATUS                 PORTS                                        NAMES
de64f0959084   grafana/grafana             "/run.sh"                8 months ago   Up 2 hours             127.0.0.1:3000->3000/tcp                     grafana
bf9a078a3627   php:8.3.2-apache            "docker-php-entrypoi…"   8 months ago   Up 2 hours             0.0.0.0:80->80/tcp, :::80->80/tcp            apache-server
14031fdccc6a   mysql/mysql-server:latest   "/entrypoint.sh mysq…"   8 months ago   Up 2 hours (healthy)   172.17.0.1:3306->3306/tcp, 33060-33061/tcp   mysql-server

```
# RCE / Privesc


Este es el proceso root que permite la escalada de privilegios:
```bash
root@bigbang:~# ps -aux

root        1751  1.0  1.8 1199704 73656 ?       Ssl  10:32   2:31 /usr/bin/python3 /root/satellite/app.py

```
En el el directorio /root encontramos el script de  lo que parece el servidor web 9090, vemos que esta desarrollado en flask y que parece el backend que maneja la base de datos

```python
root@bigbang:~# cat satellite/app.py 
from flask import Flask, request, jsonify, send_file
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from io import BytesIO
from PIL import Image
import random
import datetime
import numpy as np
import subprocess

app = Flask(__name__)

# Update the following line with your MySQL database connection details
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://satellite_user:satellite_password@172.17.0.1/satellite_db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JWT_SECRET_KEY'] = 'gUX2sShwFlHJ9MBwoXwWNghwuMenSpoi5wIL12kzXfVuNzh7G9WMysTNlnWyvvvD'

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

class Location(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    x = db.Column(db.Float, nullable=False)
    y = db.Column(db.Float, nullable=False)
    z = db.Column(db.Float, nullable=False)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.datetime.utcnow)

def create_tables():
    with app.app_context():
        db.create_all()

create_tables()

def contains_dangerous_chars(input_str):
    dangerous_chars = [
        ';',  # Separador de comandos
        "'",  # Comilla simple
        '"',  # Comilla doble
        '\\',  # Barra invertida
        '&',  # Ejecución en paralelo
        '|',  # Pipe
        '$',  # Expansión de variables
        '(',  # Paréntesis de apertura
        ')',  # Paréntesis de cierre
        '>',  # Redirección de salida
        '<',  # Redirección de entrada
        '`',  # Acento grave
        '!',  # Ejecución de comandos del historial
        '+',  # Puede ser usado en algunos contextos para comandos
        '#',  # Comentarios en shell
        '*',  # Wildcard (comodín)
        '?',  # Wildcard (comodín)
        '[',  # Inicio de clase de caracteres en expresiones regulares
        ']',  # Fin de clase de caracteres en expresiones regulares
        '{',  # Inicio de bloque de comandos o parámetros en algunas shells
        '}',  # Fin de bloque de comandos o parámetros en algunas shells
        '^',  # Redirección de error en algunas shells
        '%'  # Puede tener usos especiales en algunas shells
    ]
    return any(char in input_str for char in dangerous_chars)

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username', None)
    password = request.json.get('password', None)
    if not username or not password:
        return jsonify({'error': 'Missing username or password'}), 400
    user = User.query.filter_by(username=username).first()
    if not user or not bcrypt.check_password_hash(user.password, password):
        return jsonify({'error': 'Bad username or password'}), 401
    access_token = create_access_token(identity=username, expires_delta=datetime.timedelta(hours=1))
    return jsonify(access_token=access_token), 200

@app.route('/command', methods=['POST'])
@jwt_required()
def command():
    command = request.json.get('command', '').lower()
    current_username = get_jwt_identity()

    # Retrieve the User object corresponding to the username
    current_user = User.query.filter_by(username=current_username).first()

    if not current_user:
        return jsonify({'error': 'User not found'}), 404

    if command == 'move':
        try:
            x = float(request.json.get('x'))
            y = float(request.json.get('y'))
            z = float(request.json.get('z'))
        except (TypeError, ValueError):
            return jsonify({'error': 'Invalid coordinates. Please provide numeric values for x, y, and z.'}), 400

        # Save the coordinates into the database
        location = Location(user_id=current_user.id, x=x, y=y, z=z)
        db.session.add(location)
        db.session.commit()

        return jsonify({'status': f'{current_username} is moving to coordinates ({x}, {y}, {z})'})

    elif command == 'send_image':
        output_file = request.json.get('output_file')
        if not output_file:
            return jsonify({'error': 'Output file path must be provided'}), 400
        if contains_dangerous_chars(output_file):
            return jsonify({'error': 'Output file path contains dangerous characters'}), 400
        try:
            image_data = generate_random_image(output_file)
            return send_file(BytesIO(image_data), mimetype='image/png')
        except RuntimeError as e:
            return jsonify({'error': str(e)}), 500
    else:
        return jsonify({'error': 'Invalid command'}), 400

def generate_random_image(output_file):
    try:
        result = subprocess.run(f'/usr/local/bin/image-tool --get-image {output_file}', 
                                check=True, shell=True, capture_output=True, text=True)
        print(f"STDOUT: {result.stdout}")  # Log the standard output
        print(f"STDERR: {result.stderr}")  # Log the standard error
    except subprocess.CalledProcessError as e:
        print(f"Error executing image-tool: {e.stderr}")
        raise RuntimeError(f'Error generating image: {e.stderr}')
    
    try:
        with open(output_file, 'rb') as file:
            return file.read()
    except Exception as e:
        raise RuntimeError(f'Error reading image file: {str(e)}')

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=9090)

```
El script importa varias bibliotecas clave:

- **Flask** : Para crear la aplicación web.
- **SQLAlchemy** : Para interactuar con una base de datos MySQL.
- **Flask-Bcrypt** : Para cifrar contraseñas de usuario.
- **Flask-JWT-Extended** : Para manejar tokens JWT (JSON Web Tokens) para la autenticación.
- **Pillow (PIL)** : Para manipular imágenes.
- **Subprocess** : Para ejecutar comandos externos.


En esta parte del codigo podemos observar la vulnerabilidad que permite la escalada de privilegios:
```python
    elif command == 'send_image':
        output_file = request.json.get('output_file')
        if not output_file:
            return jsonify({'error': 'Output file path must be provided'}), 400
        if contains_dangerous_chars(output_file):
            return jsonify({'error': 'Output file path contains dangerous characters'}), 400
        try:
            image_data = generate_random_image(output_file)
            return send_file(BytesIO(image_data), mimetype='image/png')
        except RuntimeError as e:
            return jsonify({'error': str(e)}), 500
    else:
        return jsonify({'error': 'Invalid command'}), 400

def generate_random_image(output_file):
    try:
        result = subprocess.run(f'/usr/local/bin/image-tool --get-image {output_file}', 
                                check=True, shell=True, capture_output=True, text=True)
        print(f"STDOUT: {result.stdout}")  # Log the standard output
        print(f"STDERR: {result.stderr}")  # Log the standard error
    except subprocess.CalledProcessError as e:
        print(f"Error executing image-tool: {e.stderr}")
        raise RuntimeError(f'Error generating image: {e.stderr}')
    
    try:
        with open(output_file, 'rb') as file:
            return file.read()
    except Exception as e:
        raise RuntimeError(f'Error reading image file: {str(e)}')    
```

El uso de `shell=True` aumenta significativamente el riesgo de inyección de comandos porque permite que el shell interprete la cadena completa.

##### **Problema:**

- Como se mencionó anteriormente, cualquier carácter especial en `output_file` puede ser interpretado como parte del comando.

##### **Solución:**

- Evitar usar `shell=True` siempre que sea posible. En su lugar, pasar los argumentos como una lista:
```python
subprocess.run(['/usr/local/bin/image-tool', '--get-image', output_file], check=True, capture_output=True, text=True)
```