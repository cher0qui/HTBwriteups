Este archivo implementa una API RESTful con autenticación basada en tokens y conexión a Neo4j. Las principales funcionalidades incluyen:

1. Gestión de usuarios y contraseñas.
2. Autenticación segura mediante JWT.
3. Ejecución controlada de consultas Cypher.

```python
import json
import traceback
from time import sleep
from hashlib import sha1
from datetime import timedelta
from contextlib import suppress

from pydantic import BaseModel

from starlette.responses import Response, RedirectResponse

from fastapi import FastAPI, Depends, Request
from fastapi.responses import HTMLResponse
from fastapi_login import LoginManager
from fastapi_login.exceptions import InvalidCredentialsException


import logging

log = logging.getLogger("gunicorn.error")


from neo4j import GraphDatabase

# Neo4j connection details
URI = "bolt://host.docker.internal:7687"
USERNAME = "neo4j"
PASSWORD = "cU4btyib.20xtCMCXkBmerhK"

### DATABASE ###

# wait for neo4j to come up
while 1:
    try:
        driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
        with driver.session() as session:
            session.run("Match () Return 1 Limit 1")
            break
    except Exception:
        log.error(traceback.format_exc())
        sleep(1)


def create_node(tx, label, properties):
    for k,v in dict(properties).items():
        if isinstance(v, dict):
            properties.pop(k)
    query = (
        f"CREATE (n:{label} $properties)"
    )
    tx.run(query, properties=properties)

def create_relationship(tx, src, dst, type):
    query = (
        "MATCH (a), (b) "
        "WHERE a.id = $src AND b.id = $dst "
        f"CREATE (a)-[:{type}]->(b)"
    )
    tx.run(query, src=src, dst=dst)

def run_cypher(cypher):
    with driver.session() as session:
        return [r.data() for r in session.run(cypher)]


### CREATE ADMIN USER ###

for cypher in [
    "CREATE CONSTRAINT uniq_user IF NOT EXISTS FOR (user:USER) REQUIRE user.username IS UNIQUE",
    "CREATE CONSTRAINT uniq_pass IF NOT EXISTS FOR (pass:HASH) REQUIRE pass.value IS UNIQUE",
    "CREATE FULLTEXT INDEX dns_name_data_fulltext FOR (n:DNS_NAME) ON EACH [n.data]",
    """
    MERGE (u:USER {name:'graphasm'})
    MERGE (p:SHA1 {value: '9f54ca4c130be6d529a56dee59dc2b2090e43acf'})
    MERGE (u)-[:SECRET]->(p)
    """
]:
    with suppress(Exception):
        run_cypher(cypher)


### POPULATE DB ###

dns_name = run_cypher("Match (n:DNS_NAME) Return n Limit 1")
if not dns_name:
    with driver.session() as session:
        with open("webroot/sanitized.json", 'r') as file:
            events = list([json.loads(line) for line in file])
            print('creating nodes')
            for event in events:
                session.execute_write(create_node, event["type"], event)
            print('creating relationships')
            for event in events:
                session.execute_write(create_relationship, event["parent"], event["id"], event["module"])


### BASE APP ###

app = FastAPI()


@app.get("/api")
async def root():
    return RedirectResponse("/api/docs")


### SECURITY ###

class NotAuthenticatedException(Exception):
    pass

SECRET = "563e56a8078fab3dd7d3dc1e97d9af498fac07e49479dd9a83b8d028b0145226"

manager = LoginManager(SECRET, token_url="/auth", use_cookie=True, not_authenticated_exception=NotAuthenticatedException)


@app.exception_handler(NotAuthenticatedException)
def auth_exception_handler(request: Request, exc: NotAuthenticatedException):
    """
    Redirect the user to the login page if not logged in
    """
    return RedirectResponse(url="/login")


@app.get("/demo", response_class=HTMLResponse)
async def demo(user=Depends(manager)):
    with open("/app/demo.html", "r") as f:
        return f.read()


@manager.user_loader()
def load_user(username: str):
    # TODO: flesh this out
    return {"username": "graphasm"}


def verify_creds(username, password):
    cypher = (
        f"MATCH (u:USER) -[:SECRET]-> (h:SHA1) WHERE u.name = '{username}' return h.value as hash"
    )
    try:
        results = run_cypher(cypher)
        if results:
            db_hash = results[0]["hash"]
            password = password.encode(errors="ignore")
            hashed_password = sha1(password).hexdigest()
            if hashed_password == db_hash:
                return True
        return False
    except Exception:
        raise ValueError(f"Invalid cypher query: {cypher}: {traceback.format_exc()}")



class LoginForm(BaseModel):
    username: str
    password: str


@app.post("/api/auth")
def login(loginform: LoginForm):
    username = loginform.username
    password = loginform.password
    try:
        creds_valid = verify_creds(username, password)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)
    if not creds_valid:
        raise InvalidCredentialsException

    token = manager.create_access_token(
        data=dict(sub=username), expires=timedelta(hours=12)
    )
    response = Response("ok")
    response.set_cookie(key=manager.cookie_name, value=token)
    return response


@app.get("/api/cypher")
def get_nodes(query: str):
    if "alter " in query.lower() or "merge " in query.lower():
        return Response("Access denied", status_code=400)
    try:
        return run_cypher(query)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)

```

### 1. Importaciones
- **Bibliotecas estándar:**
    
    - `json`: Para trabajar con archivos JSON.
    - `traceback`: Para capturar errores y depurar.
    - `time.sleep`: Para esperar mientras Neo4j inicia.
    - `hashlib.sha1`: Para hashear contraseñas (SHA1).
    - `datetime.timedelta`: Para definir tiempos de expiración de tokens.
- **FastAPI y dependencias:**
    
    - `FastAPI`: Framework principal para construir la API.
    - `Depends`: Para manejar dependencias en las rutas.
    - `HTMLResponse`, `RedirectResponse`: Respuestas HTTP personalizadas.
    - `LoginManager`: Para manejar autenticación basada en tokens.
- **Neo4j:**
    
    - `GraphDatabase`: Cliente oficial de Neo4j para interactuar con la base de datos.
- **Logging:**
    
    - Configura un logger para registrar eventos en el servidor.



### **2. Conexión a Neo4j**

```python
URI = "bolt://host.docker.internal:7687"
USERNAME = "neo4j"
PASSWORD = "cU4btyib.20xtCMCXkBmerhK"

while 1:
    try:
        driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
        with driver.session() as session:
            session.run("Match () Return 1 Limit 1")
            break
    except Exception:
        log.error(traceback.format_exc())
        sleep(1)
```

- **Detalles de conexión:**
    
    - `URI`: Dirección del servidor Neo4j (en este caso, dentro de un contenedor Docker).
    - `USERNAME` y `PASSWORD`: Credenciales para acceder a Neo4j.
- **Espera activa:**
    
    - El bucle `while 1` intenta conectarse a Neo4j hasta que esté disponible.
    - Si falla, registra el error (`log.error`) y espera 1 segundo antes de reintentar.

### **3. Funciones para Interactuar con Neo4j**

```python
def create_node(tx, label, properties):
    for k, v in dict(properties).items():
        if isinstance(v, dict):
            properties.pop(k)
    query = f"CREATE (n:{label} $properties)"
    tx.run(query, properties=properties)

def create_relationship(tx, src, dst, type):
    query = (
        "MATCH (a), (b) "
        "WHERE a.id = $src AND b.id = $dst "
        f"CREATE (a)-[:{type}]->(b)"
    )
    tx.run(query, src=src, dst=dst)

def run_cypher(cypher):
    with driver.session() as session:
        return [r.data() for r in session.run(cypher)]
```

- **`create_node`:**
    
    - Crea un nodo en Neo4j con una etiqueta (`label`) y propiedades (`properties`).
    - Elimina propiedades anidadas (diccionarios) porque Neo4j no las soporta directamente.
- **`create_relationship`:**
    
    - Crea una relación entre dos nodos identificados por `src` y `dst`.
    - Usa parámetros (`$src`, `$dst`) para evitar inyecciones.
- **`run_cypher`:**
    
    - Ejecuta una consulta Cypher arbitraria y devuelve los resultados como una lista de diccionarios.

### **4. Creación del Usuario Admin**
```python
for cypher in [
    "CREATE CONSTRAINT uniq_user IF NOT EXISTS FOR (user:USER) REQUIRE user.username IS UNIQUE",
    "CREATE CONSTRAINT uniq_pass IF NOT EXISTS FOR (pass:HASH) REQUIRE pass.value IS UNIQUE",
    "CREATE FULLTEXT INDEX dns_name_data_fulltext FOR (n:DNS_NAME) ON EACH [n.data]",
    """
    MERGE (u:USER {name:'graphasm'})
    MERGE (p:SHA1 {value: '9f54ca4c130be6d529a56dee59dc2b2090e43acf'})
    MERGE (u)-[:SECRET]->(p)
    """
]:
    with suppress(Exception):
        run_cypher(cypher)
```

- **Restricciones e índices:**
    
    - Asegura que los nombres de usuario y hashes sean únicos.
    - Crea un índice de texto completo para nodos `DNS_NAME`.
- **Usuario admin:**
    
    - Crea un usuario `graphasm` con un hash SHA1 de contraseña (`9f54ca4c130be6d529a56dee59dc2b2090e43acf`).

### **5. Población de la Base de Datos**

```python
dns_name = run_cypher("Match (n:DNS_NAME) Return n Limit 1")
if not dns_name:
    with driver.session() as session:
        with open("webroot/sanitized.json", 'r') as file:
            events = list([json.loads(line) for line in file])
            print('creating nodes')
            for event in events:
                session.execute_write(create_node, event["type"], event)
            print('creating relationships')
            for event in events:
                session.execute_write(create_relationship, event["parent"], event["id"], event["module"])
```

- **Verificación inicial:**
    
    - Comprueba si ya existen nodos `DNS_NAME` en la base de datos.
- **Carga de datos:**
    
    - Lee un archivo JSON (`sanitized.json`) línea por línea.
    - Crea nodos y relaciones basados en los datos del archivo.
### **6. Configuración de FastAPI**

```python
app = FastAPI()

@app.get("/api")
async def root():
    return RedirectResponse("/api/docs")
```

### **7. Autenticación**
```python
class NotAuthenticatedException(Exception):
    pass

SECRET = "563e56a8078fab3dd7d3dc1e97d9af498fac07e49479dd9a83b8d028b0145226"

manager = LoginManager(SECRET, token_url="/auth", use_cookie=True, not_authenticated_exception=NotAuthenticatedException)

@app.exception_handler(NotAuthenticatedException)
def auth_exception_handler(request: Request, exc: NotAuthenticatedException):
    return RedirectResponse(url="/login")
```
- **Excepción personalizada:**
    
    - Define una excepción para manejar usuarios no autenticados.
- **Gestor de autenticación:**
    
    - Configura `LoginManager` con una clave secreta (`SECRET`) y una URL para autenticación (`/auth`).
- **Manejador de excepciones:**
    
    - Redirige a `/login` si el usuario no está autenticado.

### **8. Rutas Protegidas**


```python
@app.get("/demo", response_class=HTMLResponse)
async def demo(user=Depends(manager)):
    with open("/app/demo.html", "r") as f:
        return f.read()
```

**Acceso protegido:**

- La ruta `/demo` requiere autenticación (`Depends(manager)`).
- Devuelve el contenido de `demo.html`

### **9. Verificación de Credenciales**

```python
def verify_creds(username, password):
    cypher = (
        f"MATCH (u:USER) -[:SECRET]-> (h:SHA1) WHERE u.name = '{username}' return h.value as hash"
    )
    try:
        results = run_cypher(cypher)
        if results:
            db_hash = results[0]["hash"]
            password = password.encode(errors="ignore")
            hashed_password = sha1(password).hexdigest()
            if hashed_password == db_hash:
                return True
        return False
    except Exception:
        raise ValueError(f"Invalid cypher query: {cypher}: {traceback.format_exc()}")

class LoginForm(BaseModel):
    username: str
    password: str

@app.post("/api/auth")
def login(loginform: LoginForm):
    username = loginform.username
    password = loginform.password
    try:
        creds_valid = verify_creds(username, password)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)
    if not creds_valid:
        raise InvalidCredentialsException

    token = manager.create_access_token(
        data=dict(sub=username), expires=timedelta(hours=12)
    )
    response = Response("ok")
    response.set_cookie(key=manager.cookie_name, value=token)
    return response
```
- **Validación de credenciales:**
    
    - Consulta Neo4j para obtener el hash de la contraseña del usuario.
    - Compara el hash almacenado con el hash de la contraseña ingresada.
- **Autenticación:**
    
    - Si las credenciales son válidas, genera un token JWT y lo almacena en una cookie.

### **10. Ejecución de Consultas Cypher**

```bash
@app.get("/api/cypher")
def get_nodes(query: str):
    if "alter " in query.lower() or "merge " in query.lower():
        return Response("Access denied", status_code=400)
    try:
        return run_cypher(query)
    except Exception:
        return Response(traceback.format_exc(), status_code=400)
```
- **Ejecución de consultas:**
    - Permite ejecutar consultas Cypher directamente desde la API.
    - Bloquea consultas peligrosas (`ALTER`, `MERGE`).